// Strategy Engine - V12.0 P1/P2/P3 Dependency Decision Engine
/**
 * Determines parsing method based on Code Integrity Justification
 * Enforces P1/P2/P3 dependency rules and content analysis
 */

class StrategyEngine {
  constructor() {
    this.dependencyRules = {
      // P1: Standard Libraries (MUST USE)
      p1: {
        libraries: ['fetch', 'cheerio', 'xml2js', 'node-cron'],
        description: 'Standard/Cloud Libraries',
        justification: 'N/A - Always allowed'
      },
      
      // P2: Cloud Services (MUST USE)
      p2: {
        libraries: ['googleapis', 'aws-sdk', 'axios'],
        description: 'Cloud Services',
        justification: 'N/A - Always allowed'
      },
      
      // P3: Specialized Libraries (MUST BE JUSTIFIED)
      p3: {
        libraries: ['puppeteer', 'playwright', 'selenium'],
        description: 'Third-Party Specialized Libraries',
        justification: 'ONLY if content is Dynamic (JavaScript-loaded)'
      }
    }
    
    this.strategies = {
      'api_priority': {
        name: 'API Priority Strategy',
        priority: 'P1',
        methods: [
          { method: 'api', priority: 'P1', description: 'REST API endpoints' },
          { method: 'rss', priority: 'P1', description: 'RSS/XML feeds' },
          { method: 'static', priority: 'P1', description: 'Static HTML parsing' },
          { method: 'puppeteer', priority: 'P3', description: 'Headless browser (requires justification)' }
        ]
      },
      
      'rss_priority': {
        name: 'RSS Priority Strategy',
        priority: 'P1',
        methods: [
          { method: 'rss', priority: 'P1', description: 'RSS/XML feeds' },
          { method: 'static', priority: 'P1', description: 'Static HTML parsing' },
          { method: 'api', priority: 'P1', description: 'REST API endpoints' },
          { method: 'puppeteer', priority: 'P3', description: 'Headless browser (requires justification)' }
        ]
      },
      
      'static_priority': {
        name: 'Static Priority Strategy',
        priority: 'P1',
        methods: [
          { method: 'static', priority: 'P1', description: 'Static HTML parsing' },
          { method: 'rss', priority: 'P1', description: 'RSS/XML feeds' },
          { method: 'api', priority: 'P1', description: 'REST API endpoints' },
          { method: 'puppeteer', priority: 'P3', description: 'Headless browser (requires justification)' }
        ]
      }
    }
    
    this.contentAnalysis = {
      dynamicIndicators: [
        'data-reactid',
        'data-vue',
        'ng-app',
        'ng-controller',
        'x-data',
        'v-if',
        'v-for',
        '{{',
        '{%',
        'window.__INITIAL_STATE__',
        'window.__NUXT__',
        'window.__NEXT_DATA__'
      ],
      
      staticIndicators: [
        'noscript',
        'meta name="generator"',
        '<!-- Generated by',
        'static content',
        'server-side rendered'
      ]
    }
  }

  /**
   * Initialize the strategy engine
   */
  async initialize() {
    console.log('🔧 Initializing Strategy Engine...')
    
    // Load any cached analysis results
    await this.loadCachedAnalysis()
    
    console.log('✅ Strategy Engine initialized')
  }

  /**
   * Analyze a URL and determine the optimal parsing strategy
   * @param {string} url - The URL to analyze
   * @param {Object} options - Analysis options
   * @returns {Object} Strategy recommendation
   */
  async analyze(url, options = {}) {
    console.log(`🔍 Analyzing URL: ${url}`)
    
    try {
      // Step 1: Content Analysis
      const contentAnalysis = await this.analyzeContent(url)
      
      // Step 2: Determine Strategy
      const strategy = this.determineStrategy(url, contentAnalysis, options)
      
      // Step 3: Validate P3 Justification
      const validation = this.validateP3Justification(strategy, contentAnalysis)
      
      // Step 4: Generate Recommendation
      const recommendation = this.generateRecommendation(strategy, validation)
      
      console.log(`✅ Strategy determined: ${recommendation.method} (${recommendation.priority})`)
      
      return recommendation
      
    } catch (error) {
      console.error(`❌ Strategy analysis failed for ${url}:`, error.message)
      
      // Fallback to safe P1 strategy
      return this.getFallbackStrategy()
    }
  }

  /**
   * Analyze content to determine if it's dynamic or static
   * @param {string} url - URL to analyze
   * @returns {Object} Content analysis results
   */
  async analyzeContent(url) {
    console.log(`🔍 Analyzing content for: ${url}`)
    
    try {
      // Fetch the page content
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; DiscoveryDialBot/1.0)'
        },
        timeout: 10000
      })
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const html = await response.text()
      
      // Analyze for dynamic content indicators
      const dynamicScore = this.calculateDynamicScore(html)
      const staticScore = this.calculateStaticScore(html)
      
      // Check for JavaScript frameworks
      const frameworks = this.detectFrameworks(html)
      
      // Determine content type
      const isDynamic = dynamicScore > staticScore && dynamicScore > 0.3
      
      const analysis = {
        url: url,
        isDynamic: isDynamic,
        dynamicScore: dynamicScore,
        staticScore: staticScore,
        frameworks: frameworks,
        contentLength: html.length,
        hasJavaScript: html.includes('<script'),
        hasReact: html.includes('data-reactid') || html.includes('React'),
        hasVue: html.includes('v-if') || html.includes('Vue'),
        hasAngular: html.includes('ng-app') || html.includes('Angular'),
        timestamp: new Date().toISOString()
      }
      
      console.log(`📊 Content Analysis Results:`)
      console.log(`   Dynamic Score: ${(dynamicScore * 100).toFixed(1)}%`)
      console.log(`   Static Score: ${(staticScore * 100).toFixed(1)}%`)
      console.log(`   Is Dynamic: ${isDynamic}`)
      console.log(`   Frameworks: ${frameworks.join(', ') || 'None detected'}`)
      
      return analysis
      
    } catch (error) {
      console.error(`❌ Content analysis failed:`, error.message)
      
      // Return conservative analysis (assume static)
      return {
        url: url,
        isDynamic: false,
        dynamicScore: 0,
        staticScore: 1,
        frameworks: [],
        contentLength: 0,
        hasJavaScript: false,
        error: error.message,
        timestamp: new Date().toISOString()
      }
    }
  }

  /**
   * Calculate dynamic content score
   * @param {string} html - HTML content
   * @returns {number} Dynamic score (0-1)
   */
  calculateDynamicScore(html) {
    let score = 0
    let indicators = 0
    
    this.contentAnalysis.dynamicIndicators.forEach(indicator => {
      if (html.includes(indicator)) {
        score += 0.1
        indicators++
      }
    })
    
    // Bonus for multiple indicators
    if (indicators > 3) {
      score += 0.2
    }
    
    // Check for JavaScript frameworks
    if (html.includes('React') || html.includes('Vue') || html.includes('Angular')) {
      score += 0.3
    }
    
    return Math.min(score, 1)
  }

  /**
   * Calculate static content score
   * @param {string} html - HTML content
   * @returns {number} Static score (0-1)
   */
  calculateStaticScore(html) {
    let score = 0
    
    this.contentAnalysis.staticIndicators.forEach(indicator => {
      if (html.includes(indicator)) {
        score += 0.2
      }
    })
    
    // Bonus for server-side rendering indicators
    if (html.includes('server-side') || html.includes('SSR')) {
      score += 0.3
    }
    
    return Math.min(score, 1)
  }

  /**
   * Detect JavaScript frameworks
   * @param {string} html - HTML content
   * @returns {Array} Array of detected frameworks
   */
  detectFrameworks(html) {
    const frameworks = []
    
    if (html.includes('React') || html.includes('data-reactid')) {
      frameworks.push('React')
    }
    
    if (html.includes('Vue') || html.includes('v-if')) {
      frameworks.push('Vue')
    }
    
    if (html.includes('Angular') || html.includes('ng-app')) {
      frameworks.push('Angular')
    }
    
    if (html.includes('jQuery') || html.includes('$(')) {
      frameworks.push('jQuery')
    }
    
    return frameworks
  }

  /**
   * Determine the optimal strategy based on content analysis
   * @param {string} url - URL being analyzed
   * @param {Object} contentAnalysis - Content analysis results
   * @param {Object} options - Analysis options
   * @returns {Object} Strategy recommendation
   */
  determineStrategy(url, contentAnalysis, options) {
    const preferredStrategy = options.preferredStrategy || 'api_priority'
    const strategy = this.strategies[preferredStrategy]
    
    if (!strategy) {
      throw new Error(`Unknown strategy: ${preferredStrategy}`)
    }
    
    // Find the best method based on content analysis
    let selectedMethod = null
    
    for (const method of strategy.methods) {
      if (method.priority === 'P1' || method.priority === 'P2') {
        // P1/P2 methods are always preferred
        selectedMethod = method
        break
      } else if (method.priority === 'P3' && contentAnalysis.isDynamic) {
        // P3 methods only if content is dynamic
        selectedMethod = method
        break
      }
    }
    
    if (!selectedMethod) {
      // Fallback to first P1 method
      selectedMethod = strategy.methods.find(m => m.priority === 'P1')
    }
    
    return {
      method: selectedMethod.method,
      priority: selectedMethod.priority,
      description: selectedMethod.description,
      justification: this.generateJustification(selectedMethod, contentAnalysis),
      contentAnalysis: contentAnalysis,
      strategy: preferredStrategy
    }
  }

  /**
   * Validate P3 justification
   * @param {Object} strategy - Selected strategy
   * @param {Object} contentAnalysis - Content analysis results
   * @returns {Object} Validation results
   */
  validateP3Justification(strategy, contentAnalysis) {
    if (strategy.priority !== 'P3') {
      return {
        isValid: true,
        reason: 'Not a P3 dependency'
      }
    }
    
    const isValid = contentAnalysis.isDynamic && contentAnalysis.dynamicScore > 0.3
    
    return {
      isValid: isValid,
      reason: isValid 
        ? 'Content is dynamic (JavaScript-loaded)'
        : 'Content is static - P3 dependency not justified',
      dynamicScore: contentAnalysis.dynamicScore,
      isDynamic: contentAnalysis.isDynamic
    }
  }

  /**
   * Generate justification for the selected method
   * @param {Object} method - Selected method
   * @param {Object} contentAnalysis - Content analysis results
   * @returns {string} Justification text
   */
  generateJustification(method, contentAnalysis) {
    if (method.priority === 'P1') {
      return 'P1 Standard Library - Always allowed'
    } else if (method.priority === 'P2') {
      return 'P2 Cloud Service - Always allowed'
    } else if (method.priority === 'P3') {
      if (contentAnalysis.isDynamic) {
        return `P3 Specialized Library - Justified: Content is dynamic (${(contentAnalysis.dynamicScore * 100).toFixed(1)}% dynamic score)`
      } else {
        return 'P3 Specialized Library - NOT JUSTIFIED: Content is static'
      }
    }
    
    return 'Unknown priority level'
  }

  /**
   * Generate final recommendation
   * @param {Object} strategy - Selected strategy
   * @param {Object} validation - Validation results
   * @returns {Object} Final recommendation
   */
  generateRecommendation(strategy, validation) {
    return {
      method: strategy.method,
      priority: strategy.priority,
      description: strategy.description,
      justification: strategy.justification,
      isValid: validation.isValid,
      validation: validation,
      contentAnalysis: strategy.contentAnalysis,
      timestamp: new Date().toISOString()
    }
  }

  /**
   * Get fallback strategy (safe P1 method)
   * @returns {Object} Fallback strategy
   */
  getFallbackStrategy() {
    return {
      method: 'static',
      priority: 'P1',
      description: 'Static HTML parsing (fallback)',
      justification: 'P1 Standard Library - Fallback strategy',
      isValid: true,
      validation: { isValid: true, reason: 'Fallback strategy' },
      contentAnalysis: { isDynamic: false, dynamicScore: 0 },
      timestamp: new Date().toISOString()
    }
  }

  /**
   * Load cached analysis results
   */
  async loadCachedAnalysis() {
    // In a real implementation, this would load from a cache file
    console.log('📁 Loading cached analysis results...')
  }

  /**
   * Get strategy statistics
   * @returns {Object} Strategy usage statistics
   */
  getStatistics() {
    return {
      totalAnalyses: 0, // Would be tracked in real implementation
      p1Usage: 0,
      p2Usage: 0,
      p3Usage: 0,
      p3Justified: 0,
      p3Rejected: 0,
      lastUpdated: new Date().toISOString()
    }
  }
}

module.exports = StrategyEngine
